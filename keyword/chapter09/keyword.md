# 🎯 9주차 핵심 키워드


# Spring Data JPA의 Paging

> ***Paging**
사용자가 데이터를 요청했을 때, 전체 데이터 중 일부를 원하는 정렬 방식으로 보여주는 방식*
>

**⇒ Spring Data JPA는 페이징을 위해 Page와 Slice 인터페이스를 제공함.**

**페이징 기법 구현에 필요한 파라미터들**

- page : 페이징 기법이 적용되었을 때, 원하는 페이지
- size : 해당 페이지에 담을 데이터의 개수
- sort : 데이터 정렬 기준

**⇒ 이 데이터들은 Pageable이라는 객체로 Mapping됨.**

**Spring Data JPA의 쿼리 메소드에서 제공하는 페이징, 데이터 정렬 기능의 파라미터**

- org.springframework.data.domain.Pageable : 페이징 기능 ( 내부적으로 sort 포함 )
- org.springframework.data.domain.Sort  : 데이터 정렬 기능

## Pageable 인터페이스

> ***Pageable**
페이징에 필요한 정보를 저장하는 인터페이스로, Pageable을 구현한 PageRequest 객체를 통해 사용됨.*
>

`PageRequest pageRequest = PageRequest.of(page, size);`   **PageRequest 생성**

- Pageable 객체를 사용하면 리턴 타입은 Page<T>임.
- PageRequest 생성자의 파라미터는 현재 페이지, 조회할 데이터 수, 정렬 정보를 파라미터로 사용 할 수 있음.

# Page

```java
public interface Page<T> extends Slice<T> {
	/*
	메소드들
	*/
}
```

- Page 인터페이스는 Slice 인터페이스를 상속하므로 Slice 인터페이스의 기능을 사용할 수 있음.
- 전체 데이터의 개수를 알 수 있으며, 이를 이용한 총 페이지의 개수의 정보도 알 수 있음.
- 조회쿼리 이후 전체 데이터 개수를 조회하기 위한 추가적인 카운트 쿼리가 실행됨.
- getTotalElements() : 전체 데이터의 개수
- getTotalPages() : 전체 페이지 개수
- getContent() : 실제 데이터 리스트 불러오기
  *cf. List (자바 컬렉션): 추가 count 쿼리 없이 결과만 반환*

**⇒ 페이지 네비게이션, 전체 데이터의 크기와 총 페이지의 개수가 필요한 상황에서 사용됨.**

# Slice

```java
public interface Slice<T> extends Streamable<T> {
	/*
	메소드들
	*/
}
```

- 데이터의 일부만 가지고 있으며, 다음 페이지가 존재하는지를 확인할 수 있음.
- 전체 데이터의 개수를 모르므로, 총 페이지의 개수를 알 수 없음.
- 전체 데이터 개수를 조회하지 않고 이전 또는 다음 Slice가 존재하는지만 확인함.
- hasNext() : 다음 페이지 존재 여부 확인.

**⇒ 무한 스크롤, 데이터가 많은 상황에서 자주 사용됨.**

# 객체 그래프 탐색

## 객체와 관계형 데이터베이스의 패러다임 불일치

> ***패러다임 불일치**
객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르므로 기능과 표현 방법에 차이가 있음. 객체를 관계형 데이터베이스에 저장할 때, 관계형 데이터베이스에 있는 데이터를 객체로 가져와 조작하는 상황에서 발생하는 충돌을 뜻함.*
>

### ex1) 상속

- 객체 모델은 상속을 지원하지만, 관계형 데이터베이스에서는 상속을 지원하지 않음.

### ex2) 연관관계

- 객체 모델에서는 객체 간의 연관관계를 직접 참조로 표현할 수 있지만, 관계형 데이터베이스에서는 외래키를 이용해 표현해야 함.

### ex3) 비교

- 객체는 참조의 동등성을 비교하지만, 데이터베이스에서는 기본키를 이용해 행의 동등성을 비교함.

***따라서, 패러다임 불일치로 인해 객체 지향 프로그래밍에서는 객체 그래프 탐색을 할 수 없으므로, JPA를 이용함.***

## 객체 그래프 탐색

> ***정의**
객체 A가 있을 때, A가 참조하는 다른 객체들을 A를 통해 참조하는 것.
즉, 참조를 사용하여 연관관계를 탐색하는 것을 뜻함.*
>
- SQL을 직접 다루면 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해짐.
  ex) SQL이 B와 C까지만 조회하는 SQL이라면 B나 C까지만 참조 가능
- 객체 그래프 탐색 범위를 확인하려면, DAO를 열어 SQL을 직접 확인해야 함.
  ⇒ A와 관련된 모든 객체를 조회해서 메모리에 올려두는 것은 비현실적이므로, DAO에 A를 조회하는 여러 메소드를 만들어야 함.

***⇒ JPA를 이용하면 연관된 객체를 사용하는 시점에 적절한 SELECT SQL을 실행하므로, 객체 그래프를 원하는 만큼 탐색할 수 있음. (지연 로딩)***

***또한, JPA는 연관된 객체를 즉시 조회할지 아니면 실제 사용되는 시점에 조회할지 설정 가능함.***

## JPA

> ***정의**
Java에서 객체를 관계형 데이터베이스와 매핑(ORM: Object-Relational Mapping)하여 데이터를 저장하고 관리할 수 있도록 하는 표준 인터페이스.
ex)Hibernate*
>

### JPA를 사용하는 이유?

**<생산성 향상>**

- 직접 SQL을 작성하지 않아도 되며, CRUD가 간편해짐.
- 특히 수정 부분은 Java 컬렉션처럼 사용할 수 있어 편리함.

```java
jpa.persist(user) // 저장
User user = jpa.find(userId) // 조회
user.setName("user") // 수정
jpa.remove(user) // 삭제
```

**<유지보수 용이>**

- SQL로 매핑하는 방식을 이용하면, 엔티티에 필드가 추가 및 변경될 때마다 SQL 쿼리문을 수정해야함.
- JPA를 이용하면, 필드 변경사항이 있을 때 개발자는 엔티티에 필드를 추가 or 삭제만 하면 되고, SQL은 JPA가 처리해줌.

**<객체와 관계형 데이터베이스의 패러다임 불일치 해결>**

**상속**

- JPA는 상속관계에 있는 객체를 저장할 때 필요한 테이블에 대한 INSERT 문을 자동으로 생성함.
- 상속관계에 있는 객체를 조회 시에도 알아서 JOIN 쿼리를 생성해줌.

**연관관계, 객체 그래프 탐색**

- JPA를 사용하면 자바 컬렉션을 사용하듯이 연관관계에 있는 객체를 저장할 수 있음.
- 특정 객체를 통해 연관관계로 참조하고 있는 객체를 쉽게 가져올 수 있음.

**비교**

- JPA를 사용하면 같은 조건으로 불러온 객체에 대한 == 비교가 가능함.
- 같은 트랜잭션에서 조회한 엔티티는 같은 엔티티임을 보장해줌.