# 5주차 핵심 키워드🎯

## Domain

- 비즈니스 로직이나 애플리케이션의 핵심 개념을 나타내는 용어로 해결하고자하는 문제 영역을 뜻함
- 하나의 도메인은 하위 도메인으로 나눌 수 있음 (ex. 온라인 쇼핑몰이라는 도메인 → 결제, 장바구니, 배송 등의 하위 도메인)

## Domain Model

- 특정 문제와 관련된 모든 주제의 개념 모델로, 다양한 엔티티, 엔티티의 속성, 역할, 관계, 제약을 기술함
- 문제에 대한 솔루션은 기술하지 않음
- 도메인을 모든 사람이 동일한 관점에서 이해할 수 있고 공유할 수 있도록 단순화시킨 것

## Domain Driven Design

- 과거에는 도메인 전문가가 만든 도메인 모델을 구현 담당자가 구현함 → 이 과정에서 많은 도메인 지식의 유실이 발생 → 전문가가 요구한 소프트웨어가 만들어지지 않는 문제 발생
- 문제를 해결하고자 도메인 모델의 적용 범위를 구현까지 확장하여 도메인 지식이 구현 코드에 반영되도록 한 것이 도메인 주도 설계 방식임


## 양방향 연관관계

- 서로 간의 참조가 가능한 두 객체는 양방향 연관관계에 있음
- 즉, 하나의 외래 키로 데이터베이스 테이블 간에 서로를 참조하는 관계를 의미, 외래키를 통해 양방향 조회 가능
- 서로 다른 단방향 관계 2개로 보는 것이 더 정확함
- ex) 회원과 팀(다대일 관계), 팀과 회원(일대다 관계)

## 양방향 매핑

```java
//Memebr 클래스
@Entity
public class Member {
 
 @Id
 @Column(name = "MEMBER_ID")
 private String id;
 
 private String username;
 
 @ManyToOne
 @JoinColumn(name="TEAM_ID")
 private Team team;
 
 // 연관관계 설정
 public void setTeam(Team team) {
   this.team = team;
 }
 
 // Getter, Setter ...
}

//Team 클래스
@Entity
public class Team {
  
  @Id
  @Column(name = "TEAM_ID")
  private String id;
  
  private String name;
  
  //일대다 관계는 여러 건과 연관관계를 맺을 수 있으므로 컬렉션을 사용
  //@OneToMany 속성은 양방향 관계일 때 사용, 반대쪽 매핑의 필드 이름을 값으로 주면 됨
  @OneToMany(mappedBy = "team")
  private List<Member> members = new ArrayList<Member>();
  
  // Getter, Setter ...
 
}
```

## 양방향 매핑의 규칙 : 연관관계의 주인

**객체**

엄밀히 말하면 객체에는 양방향 연관관계가 없으며, 서로 다른 단방향 연관관계 2개를 애플리케이션 로직으로 묶어서 양방향인 것처럼 보이게 하는 것

**데이터베이스 테이블**

데이터이스 테이블은 외래 키 하나로 양쪽이 서로 조인할 수 있으므로 테이블은 외래 키 하나만으로 양방향 연관관계를 맺음

- Entity를 양방향으로 설정하면 객체의 참조는 2개인데 외래키는 1개이므로 차이가 발생함
- JPA에서는 두 객체의 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야 하는데 이것을 연관관계의 주인이라고 함

**양방향 매핑의 규칙**

- 두 연관관계 중 하나를 연관관계의 주인으로 정해야 함
- 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래 키를 관리할 수 있음. 주인이 아닌 쪽은 읽기만 가능
- 주인은 mappedBy 속성을 사용하지 않으며, 주인이 아닌 쪽에서  mappedBy 속성 값으로 연관관계의 주인을 지정함 (위의 코드에선 Member클래스의 team 필드가 Team클래스의 외래키 역할을 하며, Member클래스가 연관관계의 주인임)
- 연관관계가 주인은 외래키가 있는 곳으로 정함


## N+1 문제의 정의

특정 객체를 대상으로 수행한 쿼리가 해당 객체가 가지고 있는 연관관계 조회하게 되면서 N번의 추가적인 쿼리가 발생하는 문제

## N+1 문제의 원인과 해결방법

객체는 연관관계를 통해 레퍼런스를 가지고 있으면 언제든지 메모리 내에서 **Random Access**를 통해 연관 객체에 접근할 수 있지만 관계형 데이터베이스의 경우 **Select 쿼리**를 통해서만 조회할 수 있기 때문

**fetch 전략이 **지연(Lazy) 로딩*일 때***

> ***지연로딩**
객체를 조회하는 시점에서 실제 객체가 아닌, 가짜(프록시) 객체를 가져온 후 , 객체를 사용하는 시점에 실제 객체를 가져오도록 하는 방식*
>

findAll을 통해 엔티티 A 목록을 조회하는데 A에는 연관된 엔티티 B의 목록이 있다고 하자.

1. select * from A를 통해 A의 목록을 조회함. 이때, 지연 로딩으로 설정했으므로 B 목록은 사용하는 시점에서 가져오기 위해 가짜(프록시) 객체로 가지고 있음.
   ⇒ 쿼리 1회 발생
2. B목록을 확인하기 위해 for문을 이용하여 엔티티 A에 있는 B목록을 확인함. 이때, 엔티티 A의 B 목록은 프록시 객체이기 때문에 JPA는 1차 캐시 저장소에 현재 엔티티 A의 B목록을 확인하고, 없기 때문에 쿼리(select * from B where A_id=엔티티 A의 id)를 통해 데이터를 가져옴.
   ⇒ 쿼리 N회 발생

⇒ N+1 문제가 발생함

**해결 방법: Fetch join**

> ***Fetch join**
연관된 엔티티나 컬렉션을 한 번에 같이 조회하는 방법
사용방법: 쿼리문에 직접 fetch를 명시하기 또는 @EntityGraph 사용*
>

1. select A.*, B.* from A join fetch B 를 통해 조회하기
   ⇒ 지연로딩에서는 B의 목록이 프록시 객체로 가져와졌지만, fetch join에서는 진짜 B 객체를 가지고  옴.
   ⇒ 쿼리 1회 발생
2. 반복문을 수행할 때, B목록이 실제 객체이므로 DB를 거치지 않고 데이터를 꺼내서 반환함.

   ⇒ 쿼리 0회 발생


따라서, 1개의 쿼리로 문제를 해결할 수 있음

**fetch 전략이 즉시 로딩(EAGER)일 때**

> ***즉시 로딩**
데이터를 조회할 때 연관된 모든 객체의 데이터까지 한 번에 불러오는 방식*
>

**JPQL이 즉시 로딩 쿼리를 생성할 때 특징**

- JPQL은 처음 쿼리를 만들 때 크루에 연관관계가 있는 Entity는 신경쓰지 않고, 조회 대상이 되는 Entity 기준으로만 쿼리를 작성함
- 이후 연관관계를 확인하여 추가적인 쿼리를 발생시킴

findAll을 통해 엔티티 A 목록을 조회하는데 A에는 연관된 엔티티 B의 목록이 있다고 하자.

1. select * from A를 통해 A목록을 조회함.
   ⇒ 쿼리 1회 발생
2. A와 연관된 엔티티 B의 존재를 확인한 후, 글로벌 패치 전략을 확인함. 이때, 전략이 즉시로딩이므로 for문을 통해 select * from B where A_id=엔티티 id라는쿼리로 엔티티를 조회함.
   ⇒ N번의 쿼리 발생

따라서, N+1 문제가 발생함.

**해결방법 : 즉시로딩 사용을 지양하고, 지연 로딩 + fetch 조인 사용하기**

## Fecth Join의 문제

위에서는 즉시 로딩과 지연 로딩에서 발생하는 해결방안으로 fetch join이 등장하지만, fetch join을 사용할 때 생기는 문제도 존재함.

**대표적인 fetch join의 문제 : @OneToMany 관계의 정확한 페이징 처리가 불가능함**

- DB에서 1 : N관계를 표현하려면 한 개의 Entitiy이지만, N개의 행으로 표현을 해야함.
  ⇒ 5개의 엔티티를 불러오는 페이징 처리를 원했는데 5개의 행을 불러오는 페이징 처리가 됨.
- 문제 해결을 위해 fetch join + 페이징 처리를 하면  JPA는 fetch join한 데이터를 전부 가져온 뒤, 인메모리에 넣고 가공함.  이때, Limit 처리가 되지 않음.
  ⇒ 데이터가 많아지면 메모리 부하가 발생함

**해결방법: @ManyToOne일 때만 fetch join 사용하기 또는 @BatchSize() 사용하기**

> *@BatchSize
여러 개의 Entity를 조회할 때 지정된 Size 만큼 Where 절이 같은 여러 개의 SELECT 쿼리들을 하나의 IN 쿼리로 만들어 줌*
>

N+1문제가 발생하지 않는 것은 아니지만, select * from B where A_id=? 쿼리를 select * from B where A_id in (?,?,?) 방식으로 N+1문제가 발생하게 하여, 성능을 최적화 할 수 있음.